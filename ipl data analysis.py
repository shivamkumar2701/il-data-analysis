# -*- coding: utf-8 -*-
"""Copy of module4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ruJ_int_F1F43BVn5AmUKC9kSxRUbTcp
"""

# Commented out IPython magic to ensure Python compatibility.
# 1.	Import Libraries: Begin by importing the necessary libraries:
#       NumPy, Pandas, Statistics, Matplotlib, Seaborn, etc.

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import statistics as stats
# %matplotlib inline

# 2.	Load Data: Read the CSV file into a Pandas DataFrame.

delivery_df1=pd.read_csv("deliveries.csv")

match_df2=pd.read_csv("matches.csv")

# 3.	Data Cleaning:
# ○	Check for missing values and handle them appropriately (e.g., dropping rows/columns, imputation).
# ○	Explore the data types of each column and ensure they are correct.
# ○	Identify and handle any outliers or anomalies.

# 4.	Data Understanding:
# ○	Describe the dataset: number of rows and columns, data types, etc.
# ○	Summarize the central tendency and dispersion of numerical features (e.g., mean, median, standard deviation).
# ○	Explore the distribution of categorical features.



delivery_df1.info()
match_df2.info()

#finding null values in this data by using null function
match_df2.isnull().sum()

# # Fill null values with 0 in a specific column

match_df2['umpire3'] = match_df2['umpire3'].fillna(0)

match_df2.info()

delivery_df1.shape

match_df2.shape

print("Delivery Dataset Head")
delivery_df1.head()

delivery_df1.info()

#finding null values in this data by using null function
delivery_df1.isnull().sum()

# # Fill null values with 0
delivery_df1['player_dismissed'] = delivery_df1['player_dismissed'].fillna("NA")
delivery_df1['dismissal_kind'] = delivery_df1['dismissal_kind'].fillna("NA")
delivery_df1['fielder'] = delivery_df1['fielder'].fillna("NA")

delivery_df1.info()

print("Match Dataset head")
match_df2.head()

#describing the dataset
print("Delivery")
delivery_df1.describe()

print("Matches")
match_df2.describe()

#1. Analyze the distribution of total runs across different overs.
#Are there specific phases of the innings (e.g., powerplay, middle overs, death overs)
#where scoring rates tend to be higher or lower?

overwise_totals = delivery_df1.groupby('over')['total_runs'].sum()

# Visualize the distribution of total runs across overs
plt.figure(figsize=(10, 6))
overwise_totals.plot(kind='bar', color='orange')
plt.xlabel('Over')
plt.ylabel('Total Runs')
plt.title('Distribution of Total Runs Across Overs')
plt.show()
# Identify phases of the innings and analyze scoring rates
# For example, in T20 cricket: powerplay (overs 1-6), middle overs (overs 7-15), death overs (overs 16-20)
powerplay_runs = overwise_totals.loc[1:6].mean()
middle_overs_runs = overwise_totals.loc[7:15].mean()
death_overs_runs = overwise_totals.loc[16:].mean()

print("Average runs scored in Powerplay:", powerplay_runs)
print("Average runs scored in Middle Overs:", middle_overs_runs)
print("Average runs scored in Death Overs:", death_overs_runs)

# Filter out rows where batsman_runs are zero (to exclude non-scoring deliveries)
# 2.Explore the relationship between the batsman_runs and the type of dismissal (dismissal_kind).
# Do certain dismissal types tend to occur after batsmen have scored a significant number of runs?

data_filtered = delivery_df1[delivery_df1['batsman_runs'] > 0]

# Calculate the average runs scored for each dismissal type
avg_runs_per_dismissal = data_filtered.groupby('dismissal_kind')['batsman_runs'].mean().reset_index()

# Sort the DataFrame by average runs scored in descending order
avg_runs_per_dismissal = avg_runs_per_dismissal.sort_values(by='batsman_runs', ascending=False)

# Create a bar chart to visualize the relationship between batsman_runs and dismissal_kind
plt.figure(figsize=(10, 6))
sns.barplot(x='dismissal_kind', y='batsman_runs', data=avg_runs_per_dismissal, palette='viridis')
plt.xlabel('Dismissal Kind')
plt.ylabel('Average Batsman Runs')
plt.title('Average Batsman Runs for Each Dismissal Kind')
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
plt.show()

# 3 Calculate average runs scored per over for each batting team
# Compare the average number of total runs scored per over by different batting_teams.
# Do certain teams have consistently higher or lower scoring rates?

avg_runs_per_over_by_team = delivery_df1.groupby(['batting_team', 'over'])['total_runs'].mean().unstack()

# Visualize the comparison using a bar chart
plt.figure(figsize=(12, 8))
for team in avg_runs_per_over_by_team.index:
    plt.bar(avg_runs_per_over_by_team.columns, avg_runs_per_over_by_team.loc[team], label=team)

plt.xlabel('Over')
plt.ylabel('Average Runs per Over')
plt.title('Average Runs Scored per Over by Batting Team')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

# 4. Analyze the frequency and distribution of extras (extra_runs) conceded by bowling_teams across different overs. Are there specific phases of the game where teams tend to give away more extras?
# Assuming you have a DataFrame named 'innings_data' with columns 'over', 'extra_runs', and 'bowling_team'
# Load your dataset here

# Group the data by 'bowling_team' and 'over' and calculate the sum of extra runs conceded
extras_by_team_and_over = delivery_df1.groupby(['bowling_team', 'over'])['extra_runs'].sum().unstack()

# Calculate the total extras conceded in each over across all teams
total_extras_by_over = delivery_df1.groupby('over')['extra_runs'].sum()

# Visualize the comparison using a bar chart
plt.figure(figsize=(12, 8))
for team in extras_by_team_and_over.index:
    plt.bar(extras_by_team_and_over.columns, extras_by_team_and_over.loc[team], label=team)

plt.plot(total_extras_by_over.index, total_extras_by_over, color='black', linestyle='--', label='Total Extras')
plt.xlabel('Over')
plt.ylabel('Total Extras Conceded')
plt.title('Frequency and Distribution of Extras Conceded by Bowling Teams Across Overs')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

# 5.Explore the relationship between batsman_runs and the number of balls faced.
# Do certain batsmen score runs at a faster pace than others?

# Merge datasets based on match ID
merged_df = pd.merge(delivery_df1, match_df2, left_on='match_id', right_on='id')

# Group data by batsmen and calculate total balls faced and total runs scored
batsman_stats = merged_df.groupby('batsman').agg({'ball': 'count', 'batsman_runs': 'sum'}).reset_index()

# Calculate strike rate (runs scored per 100 balls)
batsman_stats['strike_rate'] = (batsman_stats['batsman_runs'] / batsman_stats['ball']) * 100

# Sort batsmen by strike rate
batsman_stats = batsman_stats.sort_values(by='strike_rate', ascending=False)

# Display the strike rate data
batsman_stats.head()

#6 Group the data by 'bowling_team' and 'dismissal_kind', then calculate the count of each dismissal type
dismissal_counts = delivery_df1.groupby(['bowling_team', 'dismissal_kind']).size().unstack(fill_value=0)

# Calculate the total number of dismissals for each bowling team
total_dismissals_by_team = dismissal_counts.sum(axis=1)

# Calculate the proportion of each dismissal type for each bowling team
dismissal_proportions = dismissal_counts.div(total_dismissals_by_team, axis=0)

# Visualize the distribution using a stacked bar chart
plt.figure(figsize=(12, 8))
dismissal_proportions.plot(kind='bar', stacked=True)
plt.xlabel('Bowling Team')
plt.ylabel('Proportion of Dismissals')
plt.title('Distribution of Dismissal Types Across Bowling Teams')
plt.legend(title='Dismissal Type', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.xticks(rotation=90)  # Rotate x-axis labels for better readability
plt.show()

# 7.Group the data by 'over' and count the number of wickets taken in each over
wickets_per_over = delivery_df1.groupby('over')['player_dismissed'].count()

# Visualize the relationship using a bar chart
plt.figure(figsize=(12, 8))
wickets_per_over.plot(kind='bar', color='orange')
plt.xlabel('Over')
plt.ylabel('Number of Wickets Taken')
plt.title('Number of Wickets Taken in Each Over')
plt.xticks(rotation=0)  # Rotate x-axis labels for better readability
plt.grid(axis='y')  #

# 8.Group the data by 'bowler' and 'batting_team', then calculate the average runs conceded per over for each combination
bowler_team_stats = delivery_df1.groupby(['bowler', 'batting_team']).apply(lambda x: x['total_runs'].sum() / len(x['over'].unique())).unstack()

# Create a scatter plot for each bowler against different batting teams
plt.figure(figsize=(12, 8))
for bowler in bowler_team_stats.index:
    plt.scatter(bowler_team_stats.columns, bowler_team_stats.loc[bowler], label=bowler)

plt.xlabel('Batting Team')
plt.ylabel('Average Economy Rate')
plt.title('Average Economy Rate of Bowlers Against Different Batting Teams')
plt.xticks(rotation=90)  # Rotate x-axis labels for better readability
plt.legend(title='Bowler', bbox_to_anchor=(1.05, 1), loc='upper left', ncol=3)
plt.grid(True)  # Add grid lines
plt.show()

# 9.Explore the relationship between the type of dismissal_kind and the fielder involved.
# Do certain fielders specialize in particular types of dismissals (e.g., catches, run-outs)?

# Grouping data by dismissal_kind and fielder_involved, then counting occurrences
dismissal_fielder_stats = delivery_df1.groupby(['dismissal_kind', 'fielder']).size().unstack(fill_value=0)

# Plotting the data
dismissal_fielder_stats.plot(kind='bar', stacked=True, figsize=(12, 8))
plt.xlabel('Type of Dismissal')
plt.ylabel('Frequency')
plt.title('Frequency of Each Type of Dismissal by Fielder')
plt.legend(title='Fielder', bbox_to_anchor=(1.05, 1), loc='upper left',ncol=3)
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
plt.show()

# 10.Merge datasets based on match ID
# Compare the bowling strike rate (average balls bowled per wicket) of different bowlers across different seasons.
#Are there any noticeable trends or changes in bowling effectiveness over time?

merged_df = pd.merge(delivery_df1, match_df2, left_on='match_id', right_on='id')

# Filter out rows where dismissal_kind is not null to get wickets taken
wickets_data = merged_df[merged_df['dismissal_kind'].notnull()]

# Group data by bowler and season, then calculate total balls bowled and wickets taken
bowler_season_stats = merged_df.groupby(['bowler', 'season']).agg({'ball': 'count'}).reset_index()
wickets_season = wickets_data.groupby(['bowler', 'season']).size().reset_index(name='wickets_taken')
bowler_season_stats = pd.merge(bowler_season_stats, wickets_season, on=['bowler', 'season'], how='left')

# Calculate bowling strike rate (balls bowled per wicket)
bowler_season_stats['strike_rate'] = bowler_season_stats['ball'] / bowler_season_stats['wickets_taken']

# Visualize the data
plt.figure(figsize=(12, 8))
for bowler in bowler_season_stats['bowler'].unique():
    bowler_data = bowler_season_stats[bowler_season_stats['bowler'] == bowler]
    plt.plot(bowler_data['season'], bowler_data['strike_rate'], marker='o', label=bowler)

plt.xlabel('Season')
plt.ylabel('Average Bowling Strike Rate')
plt.title('Average Bowling Strike Rate of Different Bowlers Across Seasons')
plt.legend(title='Bowler', bbox_to_anchor=(1.05, 1), loc='upper left',ncol=3)
plt.grid(True)
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
plt.show()

# 11. Analyze the distribution of runs scored by batsman across different batting positions
#(e.g., opening batsmen, middle-order batsmen). Do certain batting positions tend to score more runs?

# Identify batting positions of batsmen in each match
batting_positions = merged_df.groupby(['match_id', 'batsman'])['inning'].first().reset_index()
batting_positions['batting_position'] = batting_positions.groupby('match_id').cumcount() + 1

# Merge batting positions with runs scored
runs_scored = merged_df.groupby(['match_id', 'batsman'])['batsman_runs'].sum().reset_index()
batting_positions = pd.merge(batting_positions, runs_scored, on=['match_id', 'batsman'])

# Group data by batting position and calculate total runs scored
batting_position_stats = batting_positions.groupby('batting_position')['batsman_runs'].sum().reset_index()

# Visualize the data
plt.figure(figsize=(10, 6))
plt.bar(batting_position_stats['batting_position'], batting_position_stats['batsman_runs'], color='skyblue')
plt.xlabel('Batting Position')
plt.ylabel('Total Runs Scored')
plt.title('Distribution of Runs Scored by Batting Position')
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
plt.grid(axis='y')  # Add grid lines on the y-axis
plt.show()

# 12. Explore the relationship between the batsman and the bowler in terms of dismissal frequency.
# Do certain batsmen struggle against specific bowlers?

# Group data by pairs of batsmen and bowlers and calculate dismissal frequency
dismissal_frequency = merged_df.groupby(['batsman', 'bowler']).size().reset_index(name='dismissals')

# Visualize the data
plt.figure(figsize=(12, 8))
plt.hist(dismissal_frequency['dismissals'], bins=range(11), color='skyblue', edgecolor='black')
plt.xlabel('Dismissal Frequency')
plt.ylabel('Number of Batsman-Bowler Pairs')
plt.title('Dismissal Frequency of Batsmen Against Bowlers')
plt.xticks(range(11))
plt.grid(axis='y')  # Add grid lines on the y-axis
plt.show()

# 13. Analyze the runs scored by different pairs of batsman and non_striker to identify successful partnerships.
# Are there specific partnerships that consistently contribute significantly to the team's total score?

# Group data by pairs of batsmen and non-strikers and calculate total runs scored by each pair
partnerships = merged_df.groupby(['batsman', 'non_striker'])['batsman_runs'].sum().reset_index()

# Visualize the data
plt.figure(figsize=(12, 8))
partnerships = partnerships.sort_values(by='batsman_runs', ascending=False).head(10)  # Select top 10 partnerships
plt.barh(partnerships['batsman'] + ' - ' + partnerships['non_striker'], partnerships['batsman_runs'], color='yellow')
plt.xlabel('Total Runs Scored')
plt.ylabel('Batting Partnership')
plt.title('Top Batting Partnerships by Total Runs Scored')
plt.gca().invert_yaxis()  # Invert y-axis to display the highest partnership at the top
plt.grid(axis='x')  # Add grid lines on the x-axis
plt.show()

# 14.Compare the strike rate (runs scored per 100 balls) of individual batsmen against different bowling_teams.
# Do certain batsmen perform better against specific teams?

# Calculate balls faced and runs scored by each batsman against each bowling team
batsman_strike_rate = merged_df.groupby(['batsman', 'bowling_team']).agg({'ball': 'count', 'batsman_runs': 'sum'}).reset_index()

# Calculate strike rate (runs scored per 100 balls)
batsman_strike_rate['strike_rate'] = (batsman_strike_rate['batsman_runs'] / batsman_strike_rate['ball']) * 100

# Display the strike rate data
print(batsman_strike_rate.head())

